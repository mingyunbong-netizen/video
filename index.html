<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì˜ìƒ ë¹„êµ ë° 3D ëª¨ë¸ ë·°ì–´ (ìŒì„± ì¸ì‹ ê¸°ë¡ ë°•ìŠ¤)</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            overflow-x: hidden;
        }

        /* ------------------------------------------- */
        /* ì¶”ê°€ëœ ë¡œê³  ìŠ¤íƒ€ì¼ */
        /* ------------------------------------------- */
        #homepage-logo {
            cursor: pointer;
            position: fixed;
            top: 20px;
            left: 20px;
            font-size: 24px;
            font-weight: bold;
            font-family: 'BookkGothic', sans-serif;
            color: black;
            z-index: 100; /* ë‹¤ë¥¸ ìš”ì†Œ ìœ„ì— í‘œì‹œë˜ë„ë¡ ìµœìƒìœ„ë¡œ ì„¤ì • */
            transition: font-size 0.3s ease;
        }
        #homepage-logo:hover {
            font-size: 26px;
        }
        /* ------------------------------------------- */

        .top-comparison-section {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 30px 0 10px 0;
            box-sizing: border-box;
            background-color: #f7f7f7;
        }
        
        #voice-status-display {
            width: 1000px;
            padding: 10px;
            margin-bottom: 20px;
            text-align: center;
            font-weight: bold;
            color: #ffffff;
            background-color: #000000;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .comparison-container {
            display: flex;
            width: 1000px;
            height: 500px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .left-panel {
            width: 500px;
            height: 500px;
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            background-color: #f0f0f0;
            position: relative;
            transition: transform 0.2s ease-in-out;
        }

        .left-panel:hover {
            transform: scale(1.02);
            cursor: pointer;
        }

        .right-panel {
            width: 500px;
            height: 500px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
            background-color: #333333;
            position: relative;
        }

        #my-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #webcam-feed {
            width: 500px;
            height: 500px;
            background-color: #000;
            object-fit: cover;
            border: none;
            transform: scaleX(-1);
        }

        .loading-text {
            color: white;
            font-size: 1.2em;
            text-align: center;
            position: absolute;
            width: 500px;
        }
        
        #speech-command-overlay {
            position: absolute;
            top: 10px; 
            right: -300px; 
            width: 250px; 
            height: 480px; 
            padding: 10px;
            background: rgba(0, 0, 0, 0.65);
            color: white;
            font-size: 0.9em;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            box-sizing: border-box;
            overflow-y: auto;
            text-align: center;
            white-space: pre-wrap;
            z-index: 10;
            display: none;
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        #speech-command-overlay::-webkit-scrollbar {
            display: none;
        }
        
        #interim-text {
            color: #FFFF00; 
            font-style: italic;
        }


        #threejs-container {
            width: 100vw;
            height: 70vh;
            overflow: hidden;
            cursor: grab;
        }

        #threejs-container canvas {
            display: block;
        }
    </style>
</head>
<body>
    
    <div id="homepage-logo" onclick="goToHomePage()">
        ì„œì‚¬, ìœ„ê¸°ì†ì—ì„œ
    </div>
    <div class="top-comparison-section">
        <div id="voice-status-display">ë§ˆì´í¬ ë° ì›¹ìº  ì ‘ê·¼ ê¶Œí•œì„ í—ˆìš©í•´ ì£¼ì„¸ìš”.</div>

        <div class="comparison-container">
            <div class="left-panel" id="left-video-panel">
                <video id="my-video" autoplay playsinline>
                    <source id="video-source" src="base.mp4" type="video/mp4">
                    ì£„ì†¡í•©ë‹ˆë‹¤. ê·€í•˜ì˜ ë¸Œë¼ìš°ì €ëŠ” ë¹„ë””ì˜¤ íƒœê·¸ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
                </video>
            </div>

            <div class="right-panel">
                <div id="loading-message" class="loading-text">
                    ì›¹ìº  ë° ë§ˆì´í¬ ì ‘ê·¼ì„ ìš”ì²­ ì¤‘ì…ë‹ˆë‹¤...
                </div>
                <video id="webcam-feed" autoplay playsinline style="display: none;"></video>
                
                <div id="speech-command-overlay"></div>
            </div>
        </div>
    </div>

    <div id="threejs-container">
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        // =================================================================
        // 0. ë¡œê³  í´ë¦­ ì‹œ ì´ë™ í•¨ìˆ˜ (ìƒˆë¡œ ì¶”ê°€ë¨)
        // =================================================================
        function goToHomePage() {
            const targetUrl = 'https://mingyunbong-netizen.github.io/home/#';
            window.location.href = targetUrl;
        }
        window.goToHomePage = goToHomePage; // ì „ì—­ ìŠ¤ì½”í”„ì— ë“±ë¡í•˜ì—¬ onclickì—ì„œ í˜¸ì¶œ ê°€ëŠ¥í•˜ê²Œ í•¨


        // =================================================================
        // 1. DOM ë° ë¹„ë””ì˜¤ ì œì–´ ë¡œì§
        // =================================================================
        const videoElement = document.getElementById('webcam-feed');
        const loadingMessage = document.getElementById('loading-message');
        const myVideo = document.getElementById('my-video');
        const videoSource = document.getElementById('video-source');
        const leftVideoPanel = document.getElementById('left-video-panel');
        const voiceStatusDisplay = document.getElementById('voice-status-display');
        const speechCommandOverlay = document.getElementById('speech-command-overlay');

        const BASE_VIDEO_PATH = "base.mp4";


        if (myVideo) {
            myVideo.loop = true;
            myVideo.muted = true;
            myVideo.play().catch(error => {
                console.log("ìë™ ì¬ìƒì´ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤. í˜ì´ì§€ë¥¼ í´ë¦­í•´ ì£¼ì„¸ìš”.");
                document.addEventListener('click', () => {
                    myVideo.play().catch(e => console.log("ì¬ìƒ ì‹¤íŒ¨:", e));
                }, { once: true });
            });
        }
        
        myVideo.addEventListener('ended', () => {
            const currentVideoName = myVideo.currentSrc.substring(myVideo.currentSrc.lastIndexOf('/') + 1);
            if (currentVideoName !== BASE_VIDEO_PATH) {
                switchToBaseVideo();
            }
        });

        function switchToBaseVideo() {
            videoSource.src = BASE_VIDEO_PATH;
            myVideo.load();
            
            myVideo.loop = true;
            myVideo.muted = true;
            myVideo.play().catch(e => console.error("ê¸°ë³¸ ë¹„ë””ì˜¤ ì¬ìƒ ì‹¤íŒ¨:", e));
        }

        leftVideoPanel.addEventListener('click', () => {
            const currentVideoName = myVideo.currentSrc.substring(myVideo.currentSrc.lastIndexOf('/') + 1);
            if (currentVideoName === BASE_VIDEO_PATH) {
                playSpecificVideo('hi.mp4');
            }
        });

        function playSpecificVideo(videoPath) {
            myVideo.loop = false;
            myVideo.muted = false;

            videoSource.src = videoPath;
            myVideo.load();

            myVideo.play().catch(e => {
                console.error(`ë¹„ë””ì˜¤ ì¬ìƒ ì‹¤íŒ¨ (${videoPath}):`, e);
                myVideo.muted = true;
                myVideo.play().catch(e2 => console.error("ìŒì†Œê±° ì¬ìƒë„ ì‹¤íŒ¨:", e2));
            });
        }
        
        // =================================================================
        // 2. ìŒì„± ì¸ì‹ ë° í†µí•© ë¡œì§ (ëˆ„ì  ê¸°ë¡ ê°œì„ )
        // =================================================================

        window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

        const speechRecognition = window.SpeechRecognition ? new SpeechRecognition() : null;
        let isListening = false;
        let isMediaReady = false;
        let modelKeywordMap = {};
        
        // ëˆ„ì ëœ ìŒì„± ê¸°ë¡ì„ ì €ì¥í•˜ëŠ” ë³€ìˆ˜
        let accumulatedTranscript = '--- ìŒì„± ì¸ì‹ ê¸°ë¡ ì‹œì‘ ---\n'; 

        // ëª¨ë¸ ì •ë³´ ì •ì˜
        const modelsToLoad = [
            { name: 'shoes.glb', scale: 10, video: 'shoes.mp4' },
            { name: 'bag.glb', scale: 7, video: 'bag.mp4' },
            { name: 'ball.glb', scale: 5, video: 'Stretching.mp4' },
            { name: 'book.glb', scale: 10, video: 'book.mp4' },
            { name: 'close.glb', scale: 5, video: 'clothes.mp4' },
            { name: 'glasses.glb', scale: 20, video: 'glasses.mp4' },
            { name: 'guard.glb', scale: 10, video: 'brace.mp4' },
            { name: 'persimmon.glb', scale: 20, video: 'food.mp4' },
        ];

        // ìŒì„± ì¸ì‹ í‚¤ì›Œë“œ ë§µ ìƒì„±
        modelsToLoad.forEach(model => {
            let keyword;
            switch (model.name.split('.')[0]) { 
                case 'shoes': keyword = 'ì‹ ë°œ'; break;
                case 'bag': keyword = 'ê°€ë°©'; break;
                case 'ball': keyword = 'ê³µ'; break;
                case 'book': keyword = 'ì±…'; break;
                case 'close': keyword = 'ì˜·'; break;
                case 'glasses': keyword = 'ì•ˆê²½'; break;
                case 'guard': keyword = 'ë³´í˜¸ëŒ€'; break;
                case 'persimmon': keyword = 'ê°'; break;
                default: keyword = null;
            }
            if (keyword) {
                modelKeywordMap[keyword] = model.video;
            }
        });
        modelKeywordMap['ê¸°ë³¸'] = BASE_VIDEO_PATH; 


        function startSpeechRecognition() {
            if (!speechRecognition) {
                voiceStatusDisplay.innerText = "âŒ ìŒì„± ì¸ì‹ì´ ì§€ì›ë˜ì§€ ì•ŠëŠ” ë¸Œë¼ìš°ì €ì…ë‹ˆë‹¤.";
                return;
            }

            speechRecognition.continuous = true;
            speechRecognition.interimResults = true; 
            speechRecognition.lang = 'ko-KR';

            speechRecognition.onstart = function() {
                isListening = true;
                voiceStatusDisplay.innerText = 'ğŸŸ¢ ìŒì„± ì¸ì‹ í™œì„±í™”ë¨. "ì‹ ë°œ", "ê°€ë°©", "ê¸°ë³¸" ë“±ì„ ë§í•´ë³´ì„¸ìš”.';
                speechCommandOverlay.style.display = 'block';
                // HTMLë¡œ ëˆ„ì  ê¸°ë¡ ì´ˆê¸° í‘œì‹œ
                speechCommandOverlay.innerHTML = `<div>${accumulatedTranscript.replace(/\n/g, '<br>')}</div><span id="interim-text">...ë§ì”€í•˜ì„¸ìš”.</span>`; 
            };

            speechRecognition.onresult = function(event) {
                let interimTranscript = '';
                let finalTranscript = '';
                let latestFinalTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                        latestFinalTranscript = transcript;
                    } else {
                        interimTranscript += transcript;
                    }
                }
                
                // ìµœì¢… í…ìŠ¤íŠ¸ë¥¼ ëˆ„ì  ê¸°ë¡ ë³€ìˆ˜ì— ì¶”ê°€ (ì¤„ë°”ê¿ˆ í¬í•¨)
                if (finalTranscript) {
                    accumulatedTranscript += finalTranscript + '\n';
                }

                // í™”ë©´ì— 'ëˆ„ì ëœ ìµœì¢… ê¸°ë¡'ê³¼ 'í˜„ì¬ ë§í•˜ê³  ìˆëŠ” ì„ì‹œ í…ìŠ¤íŠ¸'ë¥¼ HTML íƒœê·¸ë¥¼ ì‚¬ìš©í•˜ì—¬ ë¶„ë¦¬í•˜ì—¬ í‘œì‹œ
                speechCommandOverlay.innerHTML = 
                    `<div>${accumulatedTranscript.replace(/\n/g, '<br>')}</div>` + 
                    `<span id="interim-text">${interimTranscript}</span>`;

                // ìŠ¤í¬ë¡¤ì´ ìƒê¸´ ê²½ìš° ê°€ì¥ ì•„ë˜ë¡œ ì´ë™
                speechCommandOverlay.scrollTop = speechCommandOverlay.scrollHeight;

                // --- ë¹„ë””ì˜¤ ëª…ë ¹ ì²˜ë¦¬ ë¡œì§ ---
                if (latestFinalTranscript) {
                    const transcript = latestFinalTranscript.trim();
                    let matchedVideoPath = null;
                    for (const keyword in modelKeywordMap) {
                        if (transcript.includes(keyword)) {
                            matchedVideoPath = modelKeywordMap[keyword];
                            break;
                        }
                    }

                    if (matchedVideoPath) {
                        voiceStatusDisplay.innerText = `ğŸ‘ ëª…ë ¹ ì¸ì‹: "${transcript}" -> ë¹„ë””ì˜¤ ì¬ìƒ ì¤‘.`;
                        
                        if (matchedVideoPath === BASE_VIDEO_PATH) {
                            switchToBaseVideo();
                        } else {
                            playSpecificVideo(matchedVideoPath);
                        }
                    } else {
                        voiceStatusDisplay.innerText = `ğŸ‘‚ ì¸ì‹: "${transcript}" -> ì¼ì¹˜í•˜ëŠ” ëª…ë ¹ ì—†ìŒ.`;
                    }
                }
            };

            speechRecognition.onerror = function(event) {
                voiceStatusDisplay.innerText = `ğŸš¨ ìŒì„± ì¸ì‹ ì˜¤ë¥˜ ë°œìƒ: ${event.error}`;
                // ì˜¤ë¥˜ ë°œìƒ ì‹œ ëˆ„ì  ê¸°ë¡ì— ì˜¤ë¥˜ ë©”ì‹œì§€ ì¶”ê°€ ë° ì—…ë°ì´íŠ¸
                accumulatedTranscript += `[ì˜¤ë¥˜: ${event.error}]\n`;
                speechCommandOverlay.innerHTML = `<div>${accumulatedTranscript.replace(/\n/g, '<br>')}</div>`;
                speechCommandOverlay.scrollTop = speechCommandOverlay.scrollHeight;
                isListening = false;
            };

            speechRecognition.onend = function() {
                isListening = false;
                // ì¸ì‹ì´ ë©ˆì¶œ ë•Œ, ì„ì‹œ í…ìŠ¤íŠ¸ë¥¼ ì œê±°í•˜ê³  ëˆ„ì  ê¸°ë¡ë§Œ í‘œì‹œ
                speechCommandOverlay.innerHTML = `<div>${accumulatedTranscript.replace(/\n/g, '<br>')}</div>`; 
                if (isMediaReady) { 
                    setTimeout(() => {
                        speechRecognition.start();
                    }, 500);
                }
            };

            try {
                speechRecognition.start();
            } catch (e) {
                // ì´ë¯¸ ì‹¤í–‰ ì¤‘ì¼ ë•Œ ë°œìƒí•˜ëŠ” ì˜¤ë¥˜ ë¬´ì‹œ
            }
        }
        
        // ì›¹ìº  ì‹œì‘ í•¨ìˆ˜: ë§ˆì´í¬ ì ‘ê·¼ì„ í¬í•¨í•˜ë„ë¡ ìœ ì§€
        async function startWebcam() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true }); 
                
                loadingMessage.style.display = 'none';
                videoElement.style.display = 'block';
                videoElement.srcObject = stream;
                isMediaReady = true;

                voiceStatusDisplay.innerText = 'âœ… ì›¹ìº  ë° ë§ˆì´í¬ ì ‘ê·¼ ì™„ë£Œ. ìŒì„± ì¸ì‹ì„ ì‹œì‘í•©ë‹ˆë‹¤.';

                // ì ‘ê·¼ ì„±ê³µ í›„ ìŒì„± ì¸ì‹ ì‹œì‘
                startSpeechRecognition(); 

            } catch (err) {
                console.error("ì›¹ìº /ë§ˆì´í¬ ì ‘ê·¼ ê¶Œí•œ ê±°ë¶€ ë˜ëŠ” ì˜¤ë¥˜ ë°œìƒ:", err);
                loadingMessage.innerText = "ì›¹ìº  ë˜ëŠ” ë§ˆì´í¬ ì ‘ê·¼ ê¶Œí•œì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤. ëª¨ë‘ í—ˆìš©í•´ ì£¼ì„¸ìš”.";
                loadingMessage.style.color = '#ff6b6b';
                voiceStatusDisplay.innerText = 'âŒ ì›¹ìº /ë§ˆì´í¬ ì ‘ê·¼ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.';
            }
        }

        window.onload = startWebcam; 

        // =================================================================
        // 3. Three.js 3D ë·°ì–´ ë¡œì§
        // =================================================================
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const threeJsContainer = document.getElementById('threejs-container');

        let intersectedObject = null;
        let originalScale = new THREE.Vector3();
        let rotationSpeed = 0.005;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // modelsToLoadëŠ” ìœ„ì—ì„œ ì •ì˜ë¨ (ì¬ì‚¬ìš©)

        const FIXED_POSITION_Y = 11.0;
        const FIXED_POSITION_Z = 0.0;
        const MODEL_SPACING_X = 3.0;
        const HOVER_SCALE_FACTOR = 1.2;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        const camera = new THREE.PerspectiveCamera(50, threeJsContainer.clientWidth / threeJsContainer.clientHeight, 0.1, 1000);
        camera.position.set(0, 0, 15);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(threeJsContainer.clientWidth, threeJsContainer.clientHeight);
        threeJsContainer.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(5, 10, 7).normalize();
        scene.add(directionalLight);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, FIXED_POSITION_Y, 0);
        controls.enablePan = false;
        controls.enableRotate = true;
        controls.maxDistance = 20;
        controls.minDistance = 5;

        const loader = new GLTFLoader();
        const modelCount = modelsToLoad.length;
        const startX = -((modelCount - 1) * MODEL_SPACING_X) / 2;

        modelsToLoad.forEach((modelInfo, index) => {
            loader.load(
                modelInfo.name,
                function (gltf) {
                    const model = gltf.scene;

                    model.position.x = startX + (index * MODEL_SPACING_X);
                    model.position.y = FIXED_POSITION_Y;
                    model.position.z = FIXED_POSITION_Z;

                    model.scale.set(modelInfo.scale, modelInfo.scale, modelInfo.scale);
                    model.userData.modelName = modelInfo.name;
                    model.userData.modelVideo = modelInfo.video;
                    model.userData.originalScale = model.scale.clone();

                    scene.add(model);
                },
                undefined,
                function (error) {
                    console.error(`ëª¨ë¸ ë¡œë“œ ì¤‘ ì—ëŸ¬ ë°œìƒ: ${modelInfo.name}`, error);
                }
            );
        });

        renderer.domElement.addEventListener('mousemove', onThreeJsMouseMove, false);
        renderer.domElement.addEventListener('click', onThreeJsClick, false);
        renderer.domElement.addEventListener('mouseleave', onThreeJsMouseLeave, false);


        let currentIntersected = null;

        function onThreeJsMouseMove(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            if (intersects.length > 0) {
                let target = intersects[0].object;
                while (target.parent && target.parent !== scene) {
                    target = target.parent;
                }

                if (target.parent === scene && target !== currentIntersected) {
                    if (currentIntersected) {
                        currentIntersected.scale.copy(currentIntersected.userData.originalScale);
                        if (currentIntersected.userData.autoRotateInterval) {
                            clearInterval(currentIntersected.userData.autoRotateInterval);
                            currentIntersected.userData.autoRotateInterval = null;
                        }
                    }

                    currentIntersected = target;
                    currentIntersected.scale.multiplyScalar(HOVER_SCALE_FACTOR);

                    if (!currentIntersected.userData.autoRotateInterval) {
                        currentIntersected.userData.autoRotateInterval = setInterval(() => {
                            currentIntersected.rotation.y += rotationSpeed * 5;
                        }, 1000 / 60);
                    }
                }
            } else {
                if (currentIntersected) {
                    currentIntersected.scale.copy(currentIntersected.userData.originalScale);
                    if (currentIntersected.userData.autoRotateInterval) {
                        clearInterval(currentIntersected.userData.autoRotateInterval);
                        currentIntersected.userData.autoRotateInterval = null;
                    }
                    currentIntersected = null;
                }
            }
        }

        function onThreeJsMouseLeave() {
            if (currentIntersected) {
                currentIntersected.scale.copy(currentIntersected.userData.originalScale);
                if (currentIntersected.userData.autoRotateInterval) {
                    clearInterval(currentIntersected.userData.autoRotateInterval);
                    currentIntersected.userData.autoRotateInterval = null;
                }
                currentIntersected = null;
            }
        }

        function onThreeJsClick(event) {
            if (currentIntersected && currentIntersected.userData.modelVideo) {
                playSpecificVideo(currentIntersected.userData.modelVideo);
            }
        }


        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = threeJsContainer.clientWidth / threeJsContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(threeJsContainer.clientWidth, threeJsContainer.clientHeight);
        });
    </script>
</body>
</html>
