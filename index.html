<script type="module">
    // ----------------------------------------------------
    // A. ì›¹ìº /ì˜ìƒ ë¹„êµ ì„¹ì…˜ JavaScript (ë³€ê²½ ì—†ìŒ)
    // ----------------------------------------------------
    const videoElement = document.getElementById('webcam-feed');
    const loadingMessage = document.getElementById('loading-message');
    const myVideo = document.getElementById('my-video'); 

    if (myVideo) {
        myVideo.play().catch(error => {
            console.log("ìžë™ ìž¬ìƒì´ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤. íŽ˜ì´ì§€ë¥¼ í´ë¦­í•´ ì£¼ì„¸ìš”.");
            document.addEventListener('click', () => {
                myVideo.play().catch(e => console.log("ìž¬ìƒ ì‹¤íŒ¨:", e));
            }, { once: true });
        });
    }

    async function startWebcam() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            loadingMessage.style.display = 'none';
            videoElement.style.display = 'block';
            videoElement.srcObject = stream;
        } catch (err) {
            console.error("ì›¹ìº  ì ‘ê·¼ ê¶Œí•œ ê±°ë¶€ ë˜ëŠ” ì˜¤ë¥˜ ë°œìƒ:", err);
            loadingMessage.innerText = "ì›¹ìº  ì ‘ê·¼ ê¶Œí•œì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤.";
            loadingMessage.style.color = '#ff6b6b';
        }
    }

    window.onload = startWebcam;


    // ----------------------------------------------------
    // B. 3D ëª¨ë¸ ë·°ì–´ ì„¹ì…˜ JavaScript (Three.js) - ë°”ë‹¥ ì¶”ê°€
    // ----------------------------------------------------
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const threeJsContainer = document.getElementById('threejs-container');

    // --- ì „ì—­ ë³€ìˆ˜ ë° ì„¤ì • ---
    let intersectedObject = null;
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    const modelsToLoad = [
        { name: 'shoes.glb', scale: 10 },
        { name: 'bag.glb', scale: 7 },
        { name: 'ball.glb', scale: 5 },
        { name: 'book.glb', scale: 10 },
        { name: 'close.glb', scale: 5 },
        { name: 'glasses.glb', scale: 20 },
        { name: 'guard.glb', scale: 10 },
        { name: 'persimmon.glb', scale: 20 },
    ];

    const FIXED_POSITION_Y = -4.0; 
    const FIXED_POSITION_Z = 0.0;
    const MODEL_SPACING_X = 3.0;
    // ----------------------------------------------------


    // 1. ê¸°ë³¸ 3ìš”ì†Œ ì„¤ì •
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xdddddd); 

    const camera = new THREE.PerspectiveCamera(50, threeJsContainer.clientWidth / threeJsContainer.clientHeight, 0.1, 1000);
    camera.position.set(0, 0, 15);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(threeJsContainer.clientWidth, threeJsContainer.clientHeight);
    threeJsContainer.appendChild(renderer.domElement); 

    // 2. ì¡°ëª… ì„¤ì •
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
    directionalLight.position.set(5, 10, 7).normalize();
    scene.add(directionalLight);

    // 3. ì»¨íŠ¸ë¡¤ ì„¤ì •
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.set(0, FIXED_POSITION_Y, 0); 
    controls.enablePan = false;
    controls.enableRotate = false; 
    controls.maxDistance = 20;
    controls.minDistance = 5;

    // 4. GLB íŒŒì¼ ë¡œë“œ!
    const loader = new GLTFLoader();
    const modelCount = modelsToLoad.length;
    const startX = -((modelCount - 1) * MODEL_SPACING_X) / 2;

    modelsToLoad.forEach((modelInfo, index) => {
        loader.load(
            modelInfo.name,
            function (gltf) {
                const model = gltf.scene;
                model.position.x = startX + (index * MODEL_SPACING_X);
                model.position.y = FIXED_POSITION_Y;
                model.position.z = FIXED_POSITION_Z;
                model.scale.set(modelInfo.scale, modelInfo.scale, modelInfo.scale);
                model.userData.modelName = modelInfo.name;
                scene.add(model);
            },
            undefined,
            function (error) {
                console.error(`ëª¨ë¸ ë¡œë“œ ì¤‘ ì—ëŸ¬ ë°œìƒ: ${modelInfo.name}`, error);
            }
        );
    });

    // 4.5. ðŸŒŸ ë°”ë‹¥ í‰ë©´(Ground Plane) ì¶”ê°€ ðŸŒŸ
    function addGroundPlane() {
        const planeGeometry = new THREE.PlaneGeometry(50, 20); // ë„“ì€ ë°”ë‹¥
        const planeMaterial = new THREE.MeshStandardMaterial({
            color: 0xcccccc, // ì—°í•œ íšŒìƒ‰ ë°”ë‹¥
            side: THREE.DoubleSide
        });
        
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        
        // ë°”ë‹¥ì´ X-Z í‰ë©´ì— ë†“ì´ë„ë¡ íšŒì „
        plane.rotation.x = Math.PI / 2;
        
        // ëª¨ë¸ë“¤ì´ ë°”ë‹¥ ìœ„ì— ì •í™•ížˆ ì„œë„ë¡ ìœ„ì¹˜ ì¡°ì •
        // FIXED_POSITION_Yê°€ ëª¨ë¸ì˜ ì¤‘ì‹¬ì ì´ë¼ë©´, ë°”ë‹¥ì€ ê·¸ë³´ë‹¤ ì•½ê°„ ì•„ëž˜ì— ë†“ê±°ë‚˜ 
        // ëª¨ë¸ì˜ í¬ê¸°ë¥¼ ê³ ë ¤í•´ì„œ ì¡°ì •í•´ì•¼ í•©ë‹ˆë‹¤.
        // í˜„ìž¬ëŠ” ëª¨ë¸ì˜ ì¤‘ì‹¬ì ê³¼ ë°”ë‹¥ì˜ ì¤‘ì‹¬ì ì„ ê°™ì€ Yì¶•ì— ë†“ì•„ ëª¨ë¸ì´ ë°”ë‹¥ì— 'ë¬»ížˆëŠ”' íš¨ê³¼ë¥¼ ì¤ë‹ˆë‹¤.
        plane.position.y = FIXED_POSITION_Y; 
        
        scene.add(plane);
    }

    addGroundPlane(); // ë°”ë‹¥ í•¨ìˆ˜ í˜¸ì¶œ


    // 5. ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€ (ê°œë³„ íšŒì „ì„ ìœ„í•œ í•µì‹¬ ë¡œì§)
    renderer.domElement.addEventListener('mousedown', onMouseDown, false);
    renderer.domElement.addEventListener('mousemove', onMouseMove, false);
    renderer.domElement.addEventListener('mouseup', onMouseUp, false);

    function onMouseDown(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);

        if (intersects.length > 0) {
            let target = intersects[0].object;
            // ë°”ë‹¥ í‰ë©´ì´ í´ë¦­ë˜ëŠ” ê²ƒì„ ë°©ì§€
            if (target.parent === scene && target.geometry.type === 'PlaneGeometry') {
                return;
            }
            
            while (target.parent && target.parent !== scene) {
                target = target.parent;
            }

            if (target.parent === scene) {
                intersectedObject = target;
                isDragging = true;
                previousMousePosition.x = event.clientX;
                previousMousePosition.y = event.clientY;
            }
        }
    }

    function onMouseMove(event) {
        if (!isDragging || !intersectedObject) return;
        const deltaX = event.clientX - previousMousePosition.x;
        intersectedObject.rotation.y += deltaX * 0.01;
        previousMousePosition.x = event.clientX;
        previousMousePosition.y = event.clientY;
    }

    function onMouseUp(event) {
        isDragging = false;
        intersectedObject = null;
    }


    // 6. ë Œë”ë§ ë£¨í”„ (ì• ë‹ˆë©”ì´ì…˜)
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }

    animate();

    // 7. ì°½ í¬ê¸° ë³€ê²½ ì‹œ í™”ë©´ ë¹„ìœ¨ ìœ ì§€
    window.addEventListener('resize', () => {
        camera.aspect = threeJsContainer.clientWidth / threeJsContainer.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(threeJsContainer.clientWidth, threeJsContainer.clientHeight);
    });
</script>
